--------------------------------------------------------------------------------
-- Functional Programming (CS141)                                             --
-- Coursework 2: Scratch clone                                                --
--------------------------------------------------------------------------------

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

-- | This module contains functions to convert XML generated by
-- Google Blockly into an AST suitable for interpretation.
module Convert where

--------------------------------------------------------------------------------

import Control.Monad
import Control.Monad.Trans.Except

import qualified Data.ByteString.Lazy as BS
import Data.Text hiding (concat)
import qualified Data.Map as M
import Data.Maybe

import Text.XML hiding (parseLBS)
import Text.HTML.DOM

import Language

--------------------------------------------------------------------------------

-- | Represents a Google Blockly XML document.
data Doc = Doc {
    docVars    :: [String],  -- ^ A list of variable names.
    docProgram :: Functions    -- ^ The program. - Modified to use custom Function storage
} deriving Show

--------------------------------------------------------------------------------

-- | Parsers from values of type r to those of type a.
type Parser r a = r -> Except String a

-- | If the node is an element, return it.
nodeToElement :: Node -> Maybe Element
nodeToElement (NodeElement e) = Just e
nodeToElement _               = Nothing

-- | If the node represents the content of an element, return it.
nodeToContent :: Node -> Maybe Text
nodeToContent (NodeContent t) = Just t
nodeToContent _               = Nothing

-- | Parses the content of an XML element.
content :: Parser [Node] Text
content = require "Missing content!" . listToMaybe . mapMaybe nodeToContent

-- | Returns all elements which satisfy the predicate.
elements :: (Element -> Maybe Element) -> [Node] -> [Element]
elements p = mapMaybe (nodeToElement >=> p)

-- | Returns all elements with the specified name.
elementsByName :: Name -> [Node] -> [Element]
elementsByName n = elements p
    where p e | elementName e == n = Just e
              | otherwise          = Nothing

-- | Returns the first element with the specified name.
element :: Name -> [Node] -> Maybe Element
element n = listToMaybe . elementsByName n

-- | Returns the first element which has the specified name
-- and name attribute.
node :: Name -> Text -> [Node] -> Maybe Element
node elemName attrName = listToMaybe . elements p
    where p e | elementName e == elemName = do
                    name <- M.lookup "name" (elementAttributes e)
                    if name == attrName then Just e else Nothing
              | otherwise = Nothing

-- | Returns the first field with the specified name.
field :: Text -> Parser [Node] Text
field n ns = case node "field" n ns of
    Nothing -> throwE $ "Missing field: " ++ unpack n
    Just e  -> content (elementNodes e)

-- | Returns all values with the specified name.
values :: Text -> Parser [Node] [Expr]
values n ns = case node "value" n ns of
    Nothing -> return []
    Just e  -> mapM parseExpr (elementsByName "block" (elementNodes e))

-- | Returns the first value with the specified name.
value :: Text -> Parser [Node] (Maybe Expr)
value t ns = listToMaybe `fmap` values t ns

statement :: Text -> Parser Element Program
statement n e = case node "statement" n (elementNodes e) of
    Nothing -> return []
    Just e' -> Prelude.concat <$>
        mapM parseStmt (elementsByName "block" (elementNodes e'))

mutations :: Parser Element (M.Map Name Text)
mutations e = case element "mutation" (elementNodes e) of
    Nothing -> return M.empty
    Just e' -> return (elementAttributes e')

-- | Requires an optional parser to succeed.
require :: String -> Parser (Maybe a) a
require ex Nothing  = throwE ex
require _  (Just x) = return x

-- | Runs an optional parser and requires it to succeed.
force :: String -> Parser (Except String (Maybe a)) a
force ex m = m >>= require ex

--------------------------------------------------------------------------------

-- | Parses a single global variable.
parseVar :: Parser Element String
parseVar (Element {..}) = do
        v <- content elementNodes
        return (unpack v)

-- | Parses the global variables section.
parseVars :: Parser Element [String]
parseVars (Element {..}) =
    mapM parseVar (elementsByName "variable" elementNodes)

parseNext :: Parser Element Program
parseNext e = case element "next" (elementNodes e) of
    Nothing -> return []
    Just e' -> Prelude.concat <$>
        mapM parseStmt (elementsByName "block" (elementNodes e'))

parseVarGet :: Parser Element Expr
parseVarGet e = do
    var <- field "VAR" (elementNodes e)
    return $ VarE (unpack var)

parseMathNumber :: Parser Element Expr
parseMathNumber e = do
    v <- field "NUM" (elementNodes e)
    return $ ValE (read $ unpack v)

parseBinOp :: Parser Element Expr
parseBinOp e = do
    op <- field "OP" (elementNodes e)
    l <- force "Left sub-expression is required" $ value "A" (elementNodes e)
    r <- force "Right sub-expression is required" $ value "B" (elementNodes e)
    return $ BinOpE (toOp op) l r
    where
        toOp :: Text -> Op
        toOp "ADD"      = Add
        toOp "MINUS"    = Sub
        toOp "MULTIPLY" = Mul
        toOp "DIVIDE"   = Div
        toOp "POWER"    = Pow
        toOp "EQ"       = Equal
        toOp "NEQ"      = Neq
        toOp "LT"       = LessThan
        toOp "LTE"      = LessOrEqual
        toOp "GT"       = GreaterThan
        toOp "GTE"      = GreaterOrEqual
        toOp _          = error "(toOp) Unknown operator"


parseVarSet :: Parser Element Program
parseVarSet e = do
    var <- field "VAR" (elementNodes e)
    val <- force "Value is required." $ value "VALUE" (elementNodes e)
    n <- parseNext e
    return $ AssignStmt (unpack var) val : n

parseRepeat :: Parser Element Program
parseRepeat e = do
    val <- force "Number of times is required." $
                value "TIMES" (elementNodes e)
    blk <- statement "DO" e
    n <- parseNext e
    return $ RepeatStmt val blk : n

parseIf :: Int -> Parser Element (Expr, Program)
parseIf i e = let n = pack (show i) in do
    cond <- force "Condition is required." $
                value ("IF" `append` n) (elementNodes e)
    stmt <- statement ("DO" `append` n) e
    return (cond, stmt)

parseControlIf :: Parser Element Program
parseControlIf e = do
    muts <- mutations e
    let elseif = fromMaybe 0 (read . unpack <$> M.lookup "elseif" muts)
    (cond,blk) <- parseIf 0 e
    alts <- mapM (flip parseIf e) [1..elseif]
    els <- statement "ELSE" e
    p <- parseNext e
    return $ IfStmt cond blk alts els : p

-- | Parses the body of an expression block.
parseExprTy :: Text -> Parser Element Expr
parseExprTy "math_number"     = parseMathNumber
parseExprTy "math_arithmetic" = parseBinOp
parseExprTy "logic_compare"   = parseBinOp
parseExprTy "variables_get"   = parseVarGet
parseExprTy "procedures_callreturn" = parseFunc -- Function Call Parser
parseExprTy ty                = const $ throwE $
    "Unknown block type: " ++ unpack ty

-- | Parses the body of a statement block.
parseStmtTy :: Text -> Parser Element Program
parseStmtTy "variables_set"       = parseVarSet
parseStmtTy "controls_repeat_ext" = parseRepeat
parseStmtTy "controls_if"         = parseControlIf
parseStmtTy "procedures_callnoreturn" = parseProc -- Procedure Call Parser
parseStmtTy "procedures_ifreturn" = parseEarlyReturn
parseStmtTy ty = const $ throwE $
    "Unknown block type: " ++ unpack ty

-- | Parses a block, including its header.
parseExpr :: Parser Element Expr
parseExpr e@(Element {..}) = case M.lookup "id" elementAttributes of
    Nothing -> throwE $
        "Block " ++ unpack (nameLocalName elementName) ++
        " is missing attribute: id"
    Just _  -> case M.lookup "type" elementAttributes of
        Nothing -> throwE "Block is missing attribute: type"
        Just ty -> parseExprTy ty e

-- | Parses a block, including its header.
parseStmt :: Parser Element Program
parseStmt e@(Element {..}) = case M.lookup "id" elementAttributes of
    Nothing -> throwE $
        "Block " ++ unpack (nameLocalName elementName) ++
        " is missing attribute: id"
    Just _  -> case M.lookup "type" elementAttributes of
        Nothing -> throwE "Block is missing attribute: type"
        Just ty -> parseStmtTy ty e

-- | Parses a Google Blockly document.
parseDoc :: Parser Element Doc
parseDoc (Element {..}) = do
    ve <- require "Variables section is missing!" $
            element "variables" elementNodes
    vs <- parseVars ve
    bs <- mapM parseFunctionBlock (elementsByName "block" elementNodes) -- TODO: only parse the entry point and ignore everything else
    return $ Doc vs (Functions bs)

-- | Tries to convert a byte string into a document.
convert :: BS.ByteString -> Either String Doc
convert = runExcept . parseDoc . documentRoot . parseLBS




-- ███████ ██   ██ ████████ ███████ ███    ██ ███████ ██  ██████  ███    ██ 
-- ██       ██ ██     ██    ██      ████   ██ ██      ██ ██    ██ ████   ██ 
-- █████     ███      ██    █████   ██ ██  ██ ███████ ██ ██    ██ ██ ██  ██ 
-- ██       ██ ██     ██    ██      ██  ██ ██      ██ ██ ██    ██ ██  ██ ██ 
-- ███████ ██   ██    ██    ███████ ██   ████ ███████ ██  ██████  ██   ████ 


-- Parsing Extension additions


-- ██████  ██████   ██████   ██████ ███████ ██████  ██    ██ ██████  ███████ ███████ 
-- ██   ██ ██   ██ ██    ██ ██      ██      ██   ██ ██    ██ ██   ██ ██      ██      
-- ██████  ██████  ██    ██ ██      █████   ██   ██ ██    ██ ██████  █████   ███████ 
-- ██      ██   ██ ██    ██ ██      ██      ██   ██ ██    ██ ██   ██ ██           ██ 
-- ██      ██   ██  ██████   ██████ ███████ ██████   ██████  ██   ██ ███████ ███████ 




-- Implementing functions/procedures should be a criminal offence :(


-- | Parses an early return statement (if _ return) and (if _ return _)
-- We default to MissingRet 1 if it doesn't have a return type as this means we can avoid using a Maybe
-- and having to add extra logic elsewhere. We can do this because procedures return memory or an error
-- thus we can check for this Expr and if it exists we can throw an error
parseEarlyReturn :: Parser Element Program
parseEarlyReturn e = do
    cond <-  force "A early return condition is required!" $ value "CONDITION" (elementNodes  e)
    retVal <- value "VALUE" (elementNodes e)
    n <- parseNext e

    return $ EarlyRet cond (fromMaybe MissingRet retVal) : n


-- | Parser that attempts to parse a Function Call
parseFunc :: Parser Element Expr
parseFunc e = do
    params <- parseFuncParams e
    muts <- mutations e
    let funcName = fromMaybe "" ( M.lookup "name" muts)
    return $ RunFunc (unpack funcName) params

-- | Parser that attempts to parse a Procedure call
parseProc :: Parser Element Program
parseProc e = do
    params <- parseFuncParams e
    muts <- mutations e
    let funcName = fromMaybe  "" (M.lookup "name" muts)
    p <- parseNext e
    return $ RunProc (unpack funcName) params : p



-- Start Param Chaos


-- | Parser that attempts to parse the function initial values (params)
parseFuncParams :: Parser Element [Stmt]
parseFuncParams e = do
    case element "mutation" (elementNodes  e) of
        Nothing -> throwE "Could not parse function params"
        Just e' -> case parseFuncParamsIter (Prelude.length (elementNodes e')) e of
            Left t -> throwE $ unpack t
            Right s -> return s

-- | Iterates over all the given initial values (if any)
-- It does this backwards, but since doing it forward or backward still results in all params being
-- present this doesn't matter
parseFuncParamsIter :: Int -> Element -> Either Text [Stmt]
parseFuncParamsIter 0 _ = Right []
parseFuncParamsIter ind e = do
    case parseFuncParam ind e of
        Left err -> Left err -- Skip broken params
        Right stmt -> do
            nex <- parseFuncParamsIter (ind-1) e
            Right $ stmt : nex


-- | Attempts to build a Stmt that will allow for initial function values (params) to work
-- | Pass back error, can't directly bind as we are switching between Maybe and Either
parseFuncParam :: Int -> Element -> Either Text Stmt
parseFuncParam ind e = do


    pn <- maybeToEither "Missing Param Name" (getParamName ind e)
    pv <- maybeToEither "Missing Param Value" (getParamValue ind e)

    Right $ AssignStmt (unpack pn) pv

--    case getParamName ind e of
--        Nothing -> Left "Missing Parameter Name"
--        Just name -> case getParamValue ind e of
--            Nothing -> Left "Missing Parameter Value!"
--            Just val -> Right $ AssignStmt (unpack name) val

-- Attempts to get the name associated with a function parameter
getParamName :: Int -> Element -> Maybe Text
getParamName ind e = do
    muts <- element "mutation" (elementNodes e)
    let nodes = elementNodes muts

    let nod = nodes !! (ind-1) -- !! Will never fail here when used with the website!

    el <- nodeToElement nod

    let attribs = elementAttributes el

    name <- M.lookup "name" attribs

    Just name

-- | Attempts to get the value associated with a function parameter
getParamValue :: Int -> Element -> Maybe Expr
getParamValue ind e = do
    let val = elementsByName "value" (elementNodes e)

    if Prelude.length val < ind then Nothing else do

        let nod = val !! (ind-1) -- !! Will never fail here when used with the website!

        block <- element "block" (elementNodes nod)

        let blockAttribs = elementAttributes block

        tp <- M.lookup "type" blockAttribs

        case tp of
            "math_number" -> getParamValueFromMath block
            "variables_get" -> getParamValueFromMath block
            "procedures_callreturn" -> getParamValueFromFunc block
            "math_arithmetic" -> getParamValueFromArith block
            _ -> Nothing

-- | Attempts to get the parsed ValE or VarE
getParamValueFromMath :: Element -> Maybe Expr
getParamValueFromMath block = do
    fied <- element "field" (elementNodes block)
    cont <- nodeToContent (Prelude.head $ elementNodes fied) -- Either "number" or "variable"

    let attribs = elementAttributes fied
    ty <- M.lookup "name" attribs

    case ty of
        "NUM" -> Just $ ValE (read (unpack cont))
        "VAR" -> Just $ VarE (unpack cont)
        _ -> Nothing

-- | Attempts to get the parsed RunFunc
getParamValueFromFunc :: Element -> Maybe Expr
getParamValueFromFunc e = do
    let fun = parseFunc e
    case runExcept fun of
        Left _ -> Nothing
        Right ep -> Just ep

-- | Attempts to get the parsed BinOpE
getParamValueFromArith :: Element -> Maybe Expr
getParamValueFromArith e = do
    let fun = parseBinOp e
    case runExcept fun of
        Left _ -> Nothing
        Right ep -> Just ep


-- End Param Chaos




-- | Parses a function block to check it has a valid ID and a type for `parseFunctionBlockTy`
parseFunctionBlock :: Parser Element (String, Func)
parseFunctionBlock e@(Element {..}) = case M.lookup "id" elementAttributes of
    Nothing -> throwE $
        "Block " ++ unpack (nameLocalName elementName) ++
        " is missing attribute: id"
    Just _  -> case M.lookup "type" elementAttributes of
        Nothing -> throwE "Block is missing attribute: type"
        Just ty -> parseFunctionBlockTy ty e

-- | Switches parsers based on the function type, with a default for the initial function
parseFunctionBlockTy :: Text -> Parser Element (String, Func)
parseFunctionBlockTy "entry_point" = parseEntryPoint
parseFunctionBlockTy "procedures_defreturn" = parseFunction
parseFunctionBlockTy "procedures_defnoreturn" = parseProcedure
parseFunctionBlockTy ty = const $ throwE $
    "Unknown Function block type: " ++ unpack ty

-- | Parses the default entry point into our custom function layout
parseEntryPoint :: Parser Element (String, Func)
parseEntryPoint e = do
    prog <- parseNext e
    return $ ("start", Func Nothing  prog)

-- | Parses a function into its name and actual function pair
parseFunction :: Parser Element (String, Func)
parseFunction e = do
    prog <- parseFuncStatement e
    let returnType = getFunctionReturnType e

    let feld = element "field" (elementNodes e)
    case feld of
        Nothing -> throwE "Missing function field"
        Just fild -> do
            let name = nodeToContent (Prelude.head (elementNodes fild))
            case name of
                Nothing -> throwE "Function has no name!"
                Just n -> return (unpack n, Func returnType prog)

-- | Returns the expression that the return type evaluates to (if any)
-- | It is possible for a function to not have a return type!
getFunctionReturnType :: Element -> Maybe Expr
getFunctionReturnType e = do
    vals <- element "value" (elementNodes e)
    block <- element "block" (elementNodes vals)
    fild <- element "field" (elementNodes  block)

    let attribs = elementAttributes fild
    typ <- M.lookup "name" attribs
    val <- nodeToContent (Prelude.head (elementNodes fild))

    case typ of
        "NUM" -> Just (ValE (read  (unpack val)))
        "VAR" -> Just (VarE (unpack val))
        "OP" -> do
            let binOp = parseBinOp block
            let res = runExcept binOp -- Parse it here instead so we can return nothing 
            case res of
                Left _ -> Nothing
                Right ep -> Just ep

        _ -> Nothing


-- | Parses a procedure into its name and actual function pair
parseProcedure :: Parser Element (String, Func)
parseProcedure e = do
    prog <- parseFuncStatement e

    let feld = element "field" (elementNodes e)
    case feld of
        Nothing -> throwE "Missing function field"
        Just fild -> do
            let name = nodeToContent (Prelude.head (elementNodes fild))

            case name of
                Nothing -> throwE "Procedure has no name!"
                Just n -> return $ ((unpack n), Func Nothing prog)


-- | Parses a function statement to get the blocks within the "statement" section
-- Similar to parse Stmt
parseFuncStatement :: Parser Element Program
parseFuncStatement e = case element "statement" (elementNodes e) of
    Nothing -> return []
    Just e' -> Prelude.concat <$>
        mapM parseStmt (elementsByName "block" (elementNodes e'))


-- | Converts a maybe to an either with a default value
maybeToEither :: a -> Maybe b -> Either a b
maybeToEither err = maybe (Left err) Right

--------------------------------------------------------------------------------
